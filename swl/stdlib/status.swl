# @file swl/status.swl
# Functions to get the information that should be in a status register:
# detection of a zero value, a negative value or overflow and parity.
#
# begin:     Tue, 28 Nov 2006 05:56:27 +0100
# last:      $Date$ by $Author$
#
#  Copyright (C) 2006, Xos√© Otero <xoseotero@users.sourceforge.net>
#
#  This program is free software; you can redistribute it and/or modify
#  it under the terms of the GNU General Public License as published by
#  the Free Software Foundation; either version 2 of the License, or
#  (at your option) any later version.
#
#  This program is distributed in the hope that it will be useful,
#  but WITHOUT ANY WARRANTY; without even the implied warranty of
#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#  GNU General Public License for more details.
#
#  You should have received a copy of the GNU General Public License
#  along with this program; if not, write to the Free Software
#  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA

# Check if the word is zero
# IN:  r0 word
# OUT: 1 if the word is zero, 0 if not
.label status_zero
	andi r0 r0 0x0000	# r0 = ro & 0
	ret



# Check if a number (signed word) is negative
# IN:  r0 the word
# OUT: r0 1 if the numbers is negative, 0 if is positive
.label status_negative
	srl r0 r0 0x001f	# r0 = has sign?
	ret



# Check if a overflow happened in a addition (signed words).
# This can be used also with a substraction by changing the order of the
# operands: a = b - c => b = a + c
# IN:  r0 the result of the addition
# IN:  r1 a operand
# IN:  r2 a operand
# OUT: r0 1 if a overlow is detected, 0 if not
.label status_overflow
  # There are some possibilites:
  # 1) Operands have different sign -> no overflow
  # 2) Operands have same sign:
  # 2.1) The result has same sign -> no overflow
  # 2.2) The result hase different sign -> overflow

  # Get the sign of the operand and result
  srl r0 r0 0x001f		# r0 = has sign?
  srl r1 r1 0x001f		# r1 = has sign?
  srl r2 r2 0x001f		# r2 = has sign?

  add r3 r1 r2			# r3 = sign(r1) + sign(r2)
  loadi r4 0x0001		# r4 = 1
  bne r3 r4 status_overflow_false	# Option 1) No overflow

  add r3 r3 r0			# r3 = sign(r1) + sign(r2) + sign(r0)
  loadi r4 0x0000			# r4 = 0
  beq r3 r4 status_overflow_false	# Option 2.1) All three with no sign
  loadi r4 0x0003			# r4 = 3
  beq r3 r4 status_overflow_false	# Option 2.2) All three with sign

  # Overflow didn't happen
  loadi r0 0x0001
  ret

  # Overflow happened
  .label status_overflow_false
  loadi r0 0x0000
  ret



# Check if a overflow happened in a addition (unsigned words).
# This can be used also with a substraction by changing the order of the
# operands: a = b - c => b = a + c
# IN:  r0 the result of the addition
# IN:  r1 a operand
# IN:  r2 a operand
# OUT: r0 1 if a overlow is detected, 0 if not
.label status_overflowu
  # Overflow happens if (r0 < r1) or (r0 < r1)
  bltu r0 r1 status_overflowu_true	# r0 < r1
  bltu r0 r2 status_overflowu_true	# r0 < r2

  # Overflow didn't happen
  loadi r0 0x0001
  ret

  # Overflow happened
  .label status_overflowu_true
  loadi r0 0x0001
  ret



# Check if the number of bits in a word are even
# IN:  r0 word
# OUT: r0 1 if the number of bits are even, 0 if the number of bits are odd
.label status_parity
  loadi r1 0x0000			# r1 = 0
  loadi r2 0x001f			# r2 = 31
  loadi r3 0x0000			# r3 = 0

  .label status_parity_continue
  beq r2 r3 status_parity_return	# if r2 == 0, then goto
					# status_parity_return
  srl r0 r0 0x0001		# r1 = r1 + ((r0 >> 1) & 0x001)
  andi r4 r0 0x0001		#
  add r1 r1 r4			#

  subi r2 r2 0x0001		# r2 = r2 - 1
  b status_parity_continue

  .label status_parity_return
  modi r0 r0 0x0010	# r0 = ro % 2
  ret
