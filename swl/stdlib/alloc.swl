# @file stdlib/alloc.swl
# Dynamic memory allocation.
#
#  Copyright (C) 2008-2010  Xos√© Otero <xoseotero@gmail.com>
#
#  This program is free software: you can redistribute it and/or modify
#  it under the terms of the GNU General Public License as published by
#  the Free Software Foundation, either version 3 of the License, or
#  (at your option) any later version.
#
#  This program is distributed in the hope that it will be useful,
#  but WITHOUT ANY WARRANTY; without even the implied warranty of
#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#  GNU General Public License for more details.
#
#  You should have received a copy of the GNU General Public License
#  along with this program.  If not, see <http://www.gnu.org/licenses/>.

.include "stdlib/def.swl"
.include "stdlib/error.swl"
.include "stdlib/address.swl"
.include "stdlib/mem.swl"

# minfo struct
.define STD_MINFO_STRUCT      0xC       # Size of the minfo struct
.define STD_MINFO_MEM         0x0       # Offset to the memory
.define STD_MINFO_TOTAL       0x4       # Offset to the total field
.define STD_MINFO_FREE        0x8       # Offset to the free field

# State of the memory allocator.
.label _std_minfo
.block STD_MINFO_STRUCT


# A block of memory has this structure:
# size: size of the block
# used: size of the data
# data: any size
# size: size of the data
.define _STD_MBLOCK_OVERHEAD  0xC       # Memory not usable of a block

.define _STD_MBLOCK_SIZE      0x0       # Offset to the size of the block
.define _STD_MBLOCK_USED      0x4       # Offset to the size of the data
.define _STD_MBLOCK_DATA      0x8       # Offset to the data of the block
.define _STD_MBLOCK_SIZE2     0xFFFC    # Offset to the size of the block
                                        # of the previous block


# Initialize a block of memory.
# IN:  g0 pointer to a block of memory
# IN:  g1 size of the block
# OUT: g1 error status
#      STD_NOERROR: no errors
#      STD_ENOMEM: block too small
.label _std_mblockinit
        # Check if the block is large enough
        loadi g2 _STD_MBLOCK_OVERHEAD
        addi g2 g2 STD_QWORDSIZE
        blt g1 g2 __std_mblockinit_enomem

        storeri g0 g1 _STD_MBLOCK_SIZE
        loadi g2 0x0
        storeri g0 g2 _STD_MBLOCK_USED
        add g0 g0 g1
        storeri g0 g1 _STD_MBLOCK_SIZE2

        loadi g1 STD_NOERROR
        ret

        .label __std_mblockinit_enomem
        loadi g1 STD_ENOMEM
        ret

# Go to the previous block of memory.
# IN:  g0 pointer to a block of memory
# OUT: g0 the previous block
# OUT: g1 error status
#      STD_NOERROR: no errors
#      STD_EINVAL: this is the first block
.label _std_mblockprev
        # check if this is the first block
        loada g1 _std_minfo
        loadri g2 g1 STD_MINFO_MEM      # g2 is the base of the memory
        beq g0 g2 _std_mblockprev_einval

        # the previous block is correct
        loadri g1 g0 _STD_MBLOCK_SIZE2
        sub g0 g0 g1

        loadi g1 STD_NOERROR
        ret

        .label _std_mblockprev_einval
        loadi g1 STD_EINVAL
        ret

# Go to the next block of memory.
# IN:  g0 pointer to a block of memory
# OUT: g0 the next block
# OUT: g1 error status
#      STD_NOERROR: no errors
#      STD_EINVAL: this is the last block
.label _std_mblocknext
        loadri g1 g0 _STD_MBLOCK_SIZE
        add g0 g0 g1

        # check if this is the last block
        loada g1 _std_minfo
        loadri g2 g1 STD_MINFO_MEM
        loadri g3 g1 STD_MINFO_TOTAL
        add g3 g3 g2                    # g3 is the top of the memory
        beq g0 g3 _std_mblocknext_einval

        # the next block is correct
        loadi g1 STD_NOERROR
        ret

        .label _std_mblocknext_einval
        loadi g1 STD_EINVAL
        ret

# Search a free block of at least size bytes for the data.
# IN:  g0 size of the data
# OUT: g0 the free block
# OUT: g1 error status
#      STD_NOERROR: no errors
#      STD_ENOMEM: there isn't memory enough
.label _std_mblocksearch
        addi g0 g0 _STD_MBLOCK_OVERHEAD
        push g0               # size is in fp + 0x0

        # search from the begining
        loada g0 _std_minfo
        loadri g0 g0 STD_MINFO_MEM

        .label __std_mblocksearch_loop
        loadri g1 fp 0x0

        loadri g2 g0 _STD_MBLOCK_USED
        bnz g2 __std_mblocksearch_next
        loadri g2 g0 _STD_MBLOCK_SIZE
        blt g2 g1 __std_mblocksearch_next

        # block found
        loadi g1 STD_NOERROR
        ret

        # try with the next block
        .label __std_mblocksearch_next
        call _std_mblocknext
        bz g1 __std_mblocksearch_loop

        .label __std_msearch_notfound
        loadi g1 STD_ENOMEM
        ret

# Divide a free block into two blocks.
# IN:  g0 pointer to the block of memory
# IN:  g1 size of the data of the first block
# OUT: g1 error status3C8
#      STD_NOERROR: no errors
#      STD_EINVAL: the bloock is in use
#      STD_ENOMEM: there is not enough space
.label _std_mblockdivide
        # check if the block is in use
        loadri g2 g0 _STD_MBLOCK_USED
        bnz g2 __std_mblockdivide_einval

        # check if there is enough space in the block to be divided in 2
        loadi g3 STD_QWORDSIZE
        addi g3 g3 _STD_MBLOCK_OVERHEAD
        multi g3 g3 0x2
        add g3 g3 g1
        loadri g2 g0 _STD_MBLOCK_SIZE
        bltu g2 g3 __std_mblockdivide_enomem

        # divide the block
        push g0               # block is in fp + 0x0
        addi g1 g1 _STD_MBLOCK_OVERHEAD
        push g1               # size is in fp + 0x4
        push g2               # total size is in fp + 0x8

        # first block
        call _std_mblockinit

        # second block
        loadri g0 fp 0x0
        call _std_mblocknext
        loadri g1 fp 0x4
        loadri g2 fp 0x8
        sub g1 g2 g1
        call _std_mblockinit

        # update the free memory
        loada g0 _std_minfo
        loadri g1 g0 STD_MINFO_FREE
        subi g1 g1 _STD_MBLOCK_OVERHEAD
        storeri g0 g1 STD_MINFO_FREE

        ret

        .label __std_mblockdivide_einval
        loadi g1 STD_EINVAL
        ret

        .label __std_mblockdivide_enomem
        loadi g1 STD_ENOMEM
        ret

# Try to join a free block of memory with the previous one and the next one.
# IN:  g0 pointer to the block of memory
# OUT: g1 error status
#      STD_NOERROR: no errors
#      STD_EINVAL: the block is in use
.label _std_mblockjoin
        # check if the block is in use
        loadri g1 g0 _STD_MBLOCK_USED
        bnz g1 __std_mblockjoin_einval

        push g0               # block is in fp + 0x0
        loadri g1 g0 _STD_MBLOCK_SIZE
        push g1               # size is in fp + 0x4

        # join with the next block
        .label __std_mblockjoin_next
        # check if the block exist
        call _std_mblocknext
        bnz g1 __std_mblockjoin_previous

        # check if the block is in use
        loadri g1 g0 _STD_MBLOCK_USED
        bnz g1 __std_mblockjoin_previous

        # calculate the size
        loadri g1 fp 0x4
        loadri g2 g0 _STD_MBLOCK_SIZE
        add g1 g1 g2
        storeri fp g1 0x4

        # join with the next block
        loadri g0 fp 0x0
        call _std_mblockinit

        # update the free memory
        loada g0 _std_minfo
        loadri g1 g0 STD_MINFO_FREE
        addi g1 g1 _STD_MBLOCK_OVERHEAD
        storeri g0 g1 STD_MINFO_FREE

        # join with the previous block
        .label __std_mblockjoin_previous
        # check if the block exists
        loadri g0 fp 0x0
        call _std_mblockprev
        bnz g1 __std_mblockjoin_ret

        # check if the block is in use
        loadri g1 g0 _STD_MBLOCK_USED
        bnz g1 __std_mblockjoin_ret

        # calculate the size
        loadri g1 fp 0x4
        loadri g2 g0 _STD_MBLOCK_SIZE
        add g1 g1 g2

        # join with the previous block
        call _std_mblockinit

        # update the free memory
        loada g0 _std_minfo
        loadri g1 g0 STD_MINFO_FREE
        addi g1 g1 _STD_MBLOCK_OVERHEAD
        storeri g0 g1 STD_MINFO_FREE

        .label __std_mblockjoin_ret
        loadi g1 STD_NOERROR
        ret

        .label __std_mblockjoin_einval
        loadi g1 STD_EINVAL
        ret

# Initialize the memory allocator
# It should not be called directly but by std_init.
# IN:  g0 memory start
# IN:  g1 size
# OUT: g1 error status
#      STD_NOERROR: no errors
#      STD_ENOMEM: the size if not enough
#      STD_EFAULT: the pointer is not valid
.label _std_minit
        push g0               # memory is in fp + 0x0
        push g1               # size is in fp + 0x4

        # Check if the size is enough
        loadi g2 _STD_MBLOCK_OVERHEAD
        ble g1 g2 __std_minit_enomem

        # check if the pointer is valid
        call std_address
        bz g0 __std_minit_efault

        # Initialize the block
        loadri g0 fp 0x0
        loadri g1 fp 0x4
        call _std_mblockinit

        # Calculate the free size
        loadri g0 fp 0x0
        loadri g1 fp 0x4
        subi g2 g1 _STD_MBLOCK_OVERHEAD

        # Set the values
        loada g3 _std_minfo
        storeri g3 g0 STD_MINFO_MEM
        storeri g3 g1 STD_MINFO_TOTAL
        storeri g3 g2 STD_MINFO_FREE

        .label __std_minit_ret
        loadi g1 STD_NOERROR
        ret

        .label __std_minit_enomem
        loadi g1 STD_ENOMEM
        ret

        .label __std_minit_efault
        loadi g1 STD_EFAULT
        ret

# Check if a address to a block of memory is valid.
# IN:  g0 block
# OUT: g0 if the address is valid
#      STD_TRUE: if the address is valid
#      STD_FALSE: if the address is not valid
.label _std_maddress
        loada g1 _std_minfo
        loadri g2 g1 STD_MINFO_MEM
        blt g0 g2 __std_maddress_invalid

        loadri g3 g1 STD_MINFO_TOTAL
        add g3 g2 g3
        bge g0 g3 __std_maddress_invalid

        .label __std_maddress_valid
        loadi g0 STD_TRUE
        ret

        .label __std_maddress_invalid
        loadi g0 STD_FALSE
        ret

# Information about the memory available and used.
# IN:  g0 pointer to a struct minfo
# OUT: g0 pointer to the struct minfo
# OUT: g1 error status
#      STD_NOERROR: no errors
#      STD_EFAULT: the pointer is not valid
.label std_minfo
        push g0               # pointer is in fp 0x0

        # check if the pointer is valid
        loadi g1 STD_MINFO_STRUCT
        call std_address
        bz g0 _std_minfo_efault

        loadri g0 fp 0x0
        loada g1 _std_minfo
        loadri g2 g1 STD_MINFO_MEM
        storeri g0 g2 STD_MINFO_MEM
        loadri g2 g1 STD_MINFO_TOTAL
        storeri g0 g2 STD_MINFO_TOTAL
        loadri g2 g1 STD_MINFO_FREE
        storeri g0 g2 STD_MINFO_FREE

        loadi g1 STD_NOERROR
        ret

        .label _std_minfo_efault
        loadi g1 STD_EFAULT
        ret

# Allocate some words of memory.
# IN:  g0 size
# OUT: g0 pointer to the allocated memory
# OUT: g1 error status
#      STD_NOERROR: no errors
#      STD_EINVAL: the size is 0
#      STD_ENOMEM: there isn't memory enough
.label std_alloc
        # check if the size is 0
        bz g0 _std_alloc_einval

        push g0               # size is in fp + 0x0

        # search a free block of memory
        call _std_mblocksearch
        bnz g1 _std_alloc_enomem

        push g0               # block is in fp + 0x4

        loadri g1 fp 0x0
        call _std_mblockdivide

        # set the size used
        loadri g0 fp 0x4
        loadri g1 fp 0x0
        storeri g0 g1 _STD_MBLOCK_USED

        # update the free memory
        loada g1 _std_minfo
        loadri g2 g1 STD_MINFO_FREE
        loadri g3 g0 _STD_MBLOCK_USED
        sub g2 g2 g3
        storeri g1 g2 STD_MINFO_FREE

        addi g0 g0 _STD_MBLOCK_DATA
        loadi g1 STD_NOERROR
        ret

        .label _std_alloc_einval
        loadi g1 STD_EINVAL
        ret

        .label _std_alloc_enomem
        #loadi g1 STD_ENOMEM  # Not needed because _std_mblocksearch already sets it
        ret

# Free a previously allocated memory.
# IN:  g0 pointer to the allocated memory
# OUT: g1 error status
#      STD_NOERROR: no errors
#      STD_EFAULT: the pointer is not valid
.label std_free
        subi g0 g0 _STD_MBLOCK_DATA
        push g0               # block is in fp + 0x0

        # check if the pointer is valid
        call _std_maddress
        bz g0 _std_free_efault

        # check that the block is used
        loadri g0 fp 0x0
        loadri g1 g0 _STD_MBLOCK_SIZE
        bz g1 _std_free_efault

        subi g1 g1 _STD_MBLOCK_OVERHEAD
        push g1               # size is in fp + 0x4

        # set the block as not used
        loadi g1 0x0
        storeri g0 g1 _STD_MBLOCK_USED

        # update the free memory
        loada g0 _std_minfo
        loadri g1 g0 STD_MINFO_FREE
        loadri g2 fp 0x4
        add g1 g1 g2
        storeri g0 g1 STD_MINFO_FREE

        loadri g0 fp 0x0
        call _std_mblockjoin

        loadi g1 STD_NOERROR
        ret

        .label _std_free_efault
        loadi g1 STD_EFAULT
        ret

# Resize a block of previously allocated memory.
# IN:  g0 pointer to the allocated memory
# IN:  g1 new size
# OUT: g0 pointer to the new allocated memory
# OUT: g1 error status
#      STD_NOERROR: no errors
#      STD_EINVAL: the size is 0
#      STD_EFAULT: the pointer is not valid
#      STD_ENOMEM: there isn't memory enough
.label std_realloc
        # check if the size is 0
        bz g0 _std_realloc_einval

        push g0               # pointer is in fp + 0x0
        push g1               # size is in fp + 0x4
        subi g2 g0 _STD_MBLOCK_DATA
        loadri g2 g2 _STD_MBLOCK_USED
        push g2               # old size is in fp + 0x8

        # check if the pointer is valid
        call _std_maddress
        bz g0 _std_realloc_efault

        # allocate the new block
        loadri g0 fp 0x4
        call std_alloc
        bnz g1 _std_realloc_enomem

        push g0               # new pointer is in fp + 0xC

        # copy the data
        loadri g1 fp 0x0
        loadri g2 fp 0x4
        loadri g3 fp 0x8
        bleu g2 g3 _std_realloc_copy
        move g2 g3
        .label _std_realloc_copy
        call std_copy

        # free the old block
        loadri g0 fp 0x0
        call std_free

        .label _std_realloc_ret
        loadri g0 fp 0xC
        loadi g1 STD_NOERROR
        ret

        .label _std_realloc_einval
        loadi g1 STD_EINVAL
        ret

        .label _std_realloc_efault
        loadi g1 STD_EFAULT
        ret

        .label _std_realloc_enomem
        loadi g1 STD_ENOMEM
        ret
