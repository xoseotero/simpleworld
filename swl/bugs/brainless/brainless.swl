# @file swl/bugs/brainless/brainless.swl
# Brainless bug.
#
# This bug does movements randomly until it detects a element that avoids its
# movement. If the element is food or a egg, the bug eats it. If the element
# is a bug, the bug attacks it. After eating, if it has enough energy, the bug
# creates a egg.
#
#  Copyright (C) 2007-2008  Xos√© Otero <xoseotero@gmail.com>
#
#  This program is free software: you can redistribute it and/or modify
#  it under the terms of the GNU General Public License as published by
#  the Free Software Foundation, either version 3 of the License, or
#  (at your option) any later version.
#
#  This program is distributed in the hope that it will be useful,
#  but WITHOUT ANY WARRANTY; without even the implied warranty of
#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#  GNU General Public License for more details.
#
#  You should have received a copy of the GNU General Public License
#  along with this program.  If not, see <http://www.gnu.org/licenses/>.

# Initialization
.label init
	loadi sp stack		# Initialize the Stack Pointer
	b main


.include "stdlib/action.swl"
.include "stdlib/random.swl"


.define ENERGY_TO_CREATE_EGG 0x40	# 64


# Main function of the bug
.label main
	call init_seed

	.label _main_loop
	call random_value
	modi r0 r0 0x2		# r0 = random_value % 2

	bz r0 _main_move
	.label _main_turn	# if random_value != 0
	call random_turn
	b _main_loop
	.label _main_move	# else (random_value == 0)
	call random_move

	bnz r0 _main_detect
	b _main_loop

	.label _main_detect	# the bug couldn't move
	call detect
	b _main_loop


# Use the actual position of the bug as the seed of the
# random number generator
.label init_seed
	world ACTION_MYSELF_POSITION
	add r0 r1 r2

	call random_seed

	ret


# Move forward or backwoard randomly
# OUT:	r0 0x0 if there is nothing in front of the bug
#          0x1 if there is something in front of the bug
.label random_move
	# r0 = random_value % 2
	call random_value
	modi r0 r0 0x2

	bz r0 _random_move_forward
	.label _random_move_backward	# if random_value != 0
	world ACTION_MOVE_BACKWARD
	loadi r0 0x0
	ret
	.label _random_move_forward	# else (random_value == 0)
	world ACTION_MOVE_FORWARD
	ret


# Turn on the left or on the right randomly
# OUT:	r0 ACTION_SUCCESS
.label random_turn
	# r0 = random_value % 2
	call random_value
	modi r0 r0 0x2

	bz r0 _random_turn_left
	.label _random_turn_right	# if random_value != 0
	world ACTION_TURN_RIGHT
	ret
	.label _random_turn_left	# else (random_value == 0)
	world ACTION_TURN_LEFT
	ret


# Attack until error
.label attack
	loadi r2 ACTION_OK

	.label _attack_loop		# do
	loadi r0 0x8
	world ACTION_ATTACK
	beq r0 r2 _attack_loop		# while ATTACK == ACTION_OK

	call detect

	ret


# Create a egg in front of the bug
.label egg
	world ACTION_EGG

	# let the egg alone
	call random_turn
	call random_move

	ret


# Eat the element that is in front of the bug
.label eat
	world ACTION_EAT

	world ACTION_MYSELF_ENERGY
	loadi r0 ENERGY_TO_CREATE_EGG
	bgt r1 r0 _eat_egg

	.label _eat_ret	# if MYSELF_ENERGY <= ENERGY_TO_CREATE_EGG
	ret

	.label _eat_egg	# else (MYSELF_ENERGY > ENERGY_TO_CREATE_EGG)
	call egg
	ret


# Detect what is in front of the bug and:
# a) eats it if the element is food or a egg
# b) attacks it if the element is a bug
.label detect
	world ACTION_DETECT		# r1 = ELEMENT

	loadi r0 ELEMENT_NOTHING
	bne r1 r0 _detect_something
	.label _detect_nothing	# if ELEMENT == NOTHING
	ret

	.label _detect_something	# else (ELEMENT != NOTHING)

	loadi r0 ELEMENT_FOOD
	beq r1 r0 _detect_eat

	.label _detect_attack		# if ELEMENT != FOOD
	call attack
	ret

	.label _detect_eat		# else (ELEMENT == FOOD)
	call eat
	ret


# The stack can't be calculate a priori because there are recursive calls
# detect->attackt->detect->...
.label stack
.block 0x40	# 64
