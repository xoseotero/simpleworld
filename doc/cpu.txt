CPU
-------------------------------------------------------------------------------
32 bits
RISC
Big Endian
64 KBytes of memory (address of 16 bits)


REGISTERS
-------------------------------------------------------------------------------
There are 16 registers: 12 general purpose registers: r0, r1, r2, ... r11 and 4
special registers:
pc (Program Counter) is the pointer to the next instruction to load from
 memory.
sgp (Segment Pointer) is the pointer to the segment of memory (64KBs) on which
the addresses of the instructions works.
stp (Stack Pointer) is the pointer to the top of the stack in memory. The stack
grows up to lower addresses.
etp (Exception Table Pointer)


EXCEPTIONS
-------------------------------------------------------------------------------
Wrong Instruction
Wrong Memory Location
Division by Zero
Timer Exception
Unknow World Command
World Event
User Event

Each exception set the information to handle them in the registers:
1. Unknow Instruction: The instruction is stored in R0 and its location is
   stored in R1.
2. Wrong Memory Location: The instruction (32 bits) is stored in R0 and its
   location is stored in R1.
3. Division by Zero: The instruction (32 bits) is stored in R0, its location is
   stored in R1 and the operators are stored in R2 and R3.
4. Timer Exception
5. Unknow World Command: Identificator of the event is stored in R0.
5. World Event: Identificator of the event is stored in R0 and the information
   of the event in the next registers.

The register etp (Excepcion Table Pointer) is a pointer to a 5 words in memory
indicating the address of the excepcion handler for each exception.
A exception can be disabled in two ways:
1. If the Exception Table Pointer is 0 all the exceptions are disabled
2. If a exception handler is 0, it's disabled.


Operation TYPES
-------------------------------------------------------------------------------
T0 = OPERATOR + VOID
     6 bits   + 24 bits

T0 = OPERATOR + VOID                + INMEDIATE
     8 bits   + 8 bits              + 16 bits

T1 = OPERATOR + REGISTER + VOID     + INMEDIATE
     8 bits   + 4 bits   + 4 bits   + 16 bits

T2 = OPERATOR + REGISTER + REGISTER + INMEDIATE
     8 bits   + 4 bits   + 4 bits   + 16 bits

T3 = OPERATOR + REGISTER + REGISTER + VOID      + REGISTER
     8 bits   + 4 bits   + 4 bits   + 12 bits   + 4 bits


OPERATIONS
-------------------------------------------------------------------------------
Management operations:
Stop the CPU:
	stop
Restart the CPU (zeroing the registers):
	restart

Load/Store operations:
Move the content of a register to a register (T2a):
	move	REG_DST REG_SRC			# REG_DST = REG_SRC
Swap the high half-word and the low half-word:
	swap	REG_DST REG_SRC
Move the content of the register to the top of the stack (T1a):
	push	REG_SRC
Move the top of the stack to a register (T1a):
	pop	REG_DST
Load a word from memory (T2b):
	load	REG_DST ADDRESS			# REG_DST = MEMORY[sgp << 16 + ADDRESS]
Load a inmediate value (T2b):
	loadi	REG_DST INMEDIATE		# REG_DST = INMEDIATE (the upper 16 bits are cleared)
Load a word from memory using two base registers:
	loadrr	REG_DST	REG_BASE REG_OFFSET	# REG_DST = MEMORY[REG_BASE + REG_OFFSET]
Load a word from memory using a base register and a inmediate value:
	loadri	REG_DST REG_BASE INMEDIATE	# REG_DST = MEMORY[REG_BASE + INMNEDIATE]
Store a word to memory (T2b):
	store	ADDRESS REG_SRC			# MEMORY[sgp << 16 + ADDRESS] = REG_SRC
Store a word to memory using two base registers:
	storerr	REG_BASE REG_OFFSET REG_SRC	# MEMORY[REG_BASE + REG_OFFSET] = REG_SRC
Store a word to memory using a base register and a inmediate value:
	storeri	REG_BASE INMEDIATE REG_SRC	# MEMORY[REG_BASE + INMEDIATE] = REG_SRC

Jump operations:
Call a function:
	call	ADDRESS			# pc = sgp << 16 + ADDRESS
Return:
	ret				# pc = stp
Return from exception:
	rete				# pc = stp and restore registers from
					  stack
Call a World function (T1a):
	world	REG_OP REG_P1 REG_P2	# Execute the REG_OP operation in world

with REG_P1 and REG_P2 parameters
Branch always:
	b	ADDRESS			# pc = sgp << 16 + ADDRESS
Branch on equal (T2b):
	beq	REG1 REG2 ADDRESS	# if REG1 == REG2 then pc = sgp << 16 + ADDRESS
Branch on not equal (T2b):
	bne	REG1 REG2 ADDRESS	# if REG1 != REG2 then pc = sgp << 16 + ADDRESS
Branch on less than (T2b):
	blt	REG1 REG2 ADDRESS	# if REG1 < REG2 then pc = sgp << 16 + ADDRESS
	bltu	REG1 REG2 ADDRESS	# if REG1 < REG2 then pc = sgp << 16 + ADDRESS (unsigned comparission)
Branch on great than (T2b):
	bgt	REG1 REG2 ADDRESS	# if REG1 > REG2 then pc = sgp << 16 + ADDRESS
	bgtu	REG1 REG2 ADDRESS	# if REG1 > REG2 then pc = sgp << 16 + ADDRESS (unsigned comparission)
Branch on less or equal:
	ble	REG1 REG2 ADDRESS	# if REG1 <= REG2 then pc = sgp << 16 + ADDRESS
	bleu	REG1 REG2 ADDRESS	# if REG1 <= REG2 then pc = sgp << 16 + ADDRESS (unsigned comparission)
Branch on greater or equal:
	bge	REG1 REG2 ADDRESS	# if REG1 >= REG2 then pc = sgp << 16 + ADDRESS
	bgeu	REG1 REG2 ADDRESS	# if REG1 >= REG2 then pc = sgp << 16 + ADDRESS (unsigned comparission)

Arithmetic operations:
Add (T3):
	add	REG_DST REG_SRC1 REG_SRC2	# REG_DST = REG_SRC1 + REG_SRC2
	addi	REG_DST REG_SRC INMEDIATE	# REG_DST = REG_SRC + INMEDIATE
Substract (T3):
	sub	REG_DST REG_SRC1 REG_SRC2	# REG_DST = REG_SRC1 - REG_SRC2
	subi	REG_DST REG_SRC INMEDIATE	# REG_DST = REG_SRC - INMEDIATE
Multiply (low 32 bits) (T3):
	multl	REG_DST REG_SRC1 REG_SRC2	# REG_DST = REG_SRC1 * REG_SRC2
	multli	REG_DST REG_SRC INMEDIATE	# REG_DST = REG_SRC * INMEDIATE
	multlu	REG_DST REG_SRC1 REG_SRC2	# REG_DST = REG_SRC1 * REG_SRC2 (unsigned integer)
	multlui	REG_DST REG_SRC INMEDIATE	# REG_DST = REG_SRC * INMEDIATE (unsigned integer)
Multiply (high 32 bits) (T3):
	multh	REG_DST REG_SRC1 REG_SRC2	# REG_DST = REG_SRC1 * REG_SRC2
	multhi	REG_DST REG_SRC INMEDIATE	# REG_DST = REG_SRC * INMEDIATE
	multhu	REG_DST REG_SRC1 REG_SRC2	# REG_DST = REG_SRC1 * REG_SRC2 (unsigned integer)
	multhui	REG_DST REG_SRC INMEDIATE	# REG_DST = REG_SRC * INMEDIATE (unsigned integer)
Divide (T3):
	div	REG_DST REG_SRC1 REG_SRC2	# REG_DST = REG_SRC1 / REG_SRC2
	divi	REG_DST REG_SRC INMEDIATE	# REG_DST = REG_SRC / INMEDIATE
	divu	REG_DST REG_SRC1 REG_SRC2	# REG_DST = REG_SRC1 / REG_SRC2 (unsigned integer)
	divui	REG_DST REG_SRC INMEDIATE	# REG_DST = REG_SRC / INMEDIATE (unsigned integer)
Module:
	mod	REG_DST REG_SRC1 REG_SRC2	# REG_DST = REG_SRC1 % REG_SRC2
	modi	REG_DST REG_SRC INMEDIATE	# REG_DST = REG_SRC % INMEDIATE
	modu	REG_DST REG_SRC1 REG_SRC2	# REG_DST = REG_SRC1 % REG_SRC2
	modui	REG_DST REG_SRC INMEDIATE	# REG_DST = REG_SRC % INMEDIATE

Logical operations:
Not (T3):
	not	REG_DST REG_SRC			# REG_DST = ~ REG_SRC
Or (T3):
	or	REG_DST REG_SRC1 REG_SRC2	# REG_DST = REG_SRC1 | REG_SRC2
	ori	REG_DST REG_SRC INMEDIATE	# REG_DST = REG_SRC | INMEDIATE
And (T3):
	and	REG_DST REG_SRC1 REG_SRC2	# REG_DST = REG_SRC1 & REG_SRC2
	andi	REG_DST REG_SRC INMEDIATE	# REG_DST = REG_SRC & INMEDIATE
Exor (T3):
	xor	REG_DST REG_SRC1 REG_SRC2	# REG_DST = REG_SRC1 ^ REG_SRC2
	xori	REG_DST REG_SRC INMEDIATE	# REG_DST = REG_SRC ^ INMEDIATE

Shift operations:
Logic shift left (T3):
	sll REG_DST REG_SRC REG_OFFSET	# REG_DST = REG_SRC << REG_OFFSET
	slli REG_DST REG_SRC INMEDIATE	# REG_DST = REG_SRC << INMEDIATE
Logic shift right (T3):
	srl REG_DST REG_SRC REG_OFFSET	# REG_DST = REG_SRC >> REG_OFFSET
	srli REG_DST REG_SRC INMEDIATE	# REG_DST = REG_SRC >> INMEDIATE
Arithmetic shift left (T3):
	sla REG_DST REG_SRC REG_OFFSET	# REG_DST = REG_SRC << REG_OFFSET
	slai REG_DST REG_SRC INMEDIATE	# REG_DST = REG_SRC << INMEDIATE
Arithmetic shift right (T3):
	sra REG_DST REG_SRC REG_OFFSET	# REG_DST = REG_SRC >> REG_OFFSET
	srai REG_DST REG_SRC INMEDIATE	# REG_DST = REG_SRC >> INMEDIATE
Rotate left:
	rl REG_DST REG_SRC REG_OFFSET	# REG_DST = REG_SRC << REG_OFFSET
	rli REG_DST REG_SRC INMEDIATE	# REG_DST = REG_SRC << INMEDIATE
Rotate right:
	rr REG_DST REG_SRC REG_OFFSET	# REG_DST = REG_SRC >> REG_OFFSET
	rri REG_DST REG_SRC INMEDIATE	# REG_DST = REG_SRC >> INMEDIATE


BINARY CODES
-------------------------------------------------------------------------------
r0        = 0x0
r1        = 0x1
r2        = 0x2
r3        = 0x3
r4        = 0x4
r5        = 0x5
r6        = 0x6
r7        = 0x7
r8        = 0x8
r9        = 0x9
r10       = 0xa
r11       = 0xb
pc        = 0xc
spc       = 0xd
stp       = 0xe
etp       = 0xf


ASSEMBLER
-------------------------------------------------------------------------------
The program begins with the first instruction of the program. Registers are
initialized to 0x00000000.

Constants:
All the constants are searched in the code before compilation. It cannot have
two constants with he himself name. The value of a constant must be a number.
Example: .define CONSTAT VALUE

Includes:
Files can be included into files. A file is included only one time.
Example: .include "FILENAME"

Labels:
Labels can be used to break the code flow (gotos, functions calls, etc).
Example: .label LABELNAME

Function conventions:
General purpose registers can change after a function call.
The registers are used to set the input and output values for the function.


FIBONACCI ALGORITHM
-------------------------------------------------------------------------------
.include "memory.swl"
.include "time.swl"
.include "random.swl"

.define MAX_FIBONACCI 0x8000	# 32768

.label MAIN
# set in R0, R1 and R2 the values for FIBONACCI function
loadi	R0 1		# First value is 1
loadi	R1 1		# Second value is 1
loadi	R2 MAX_FIBONACCI	# Max value is MAX_FIBONACCI

call	FIBONACCI	# call FIBONACCI

b	MAIN		# infinite loop


# Fibonacci algorithm
# R0 = First value
# R1 = Second value
# R2 = Max value
.label FIBONACCI	# loop
add	R3 R0 R1	# R3 = R0 + R1
move	R0 R1		# R0 = R1
move	R1 R3		# R1 = R3

bltu	R1 R2 FIBONACCI	# if R1 < R2: LOOP
ret			# else: return


.label DATA		# No data
